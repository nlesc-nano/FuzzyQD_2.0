# cube.py
from __future__ import annotations
import os, io, math, time
import numpy as np
from concurrent.futures import ThreadPoolExecutor

from pymatgen.core import Element
from . import config
import libint_fuzzy  # now exposes project_mos_points(...)

def atomic_numbers_from_symbols(syms):
    return np.array([Element(s).Z for s in syms], dtype=int)

def center_of_mass(Z, R_bohr):
    masses = np.array([Element.from_Z(int(z)).atomic_mass for z in Z], dtype=float)
    masses = np.array([float(m) for m in masses])
    com = (masses[:,None] * R_bohr).sum(axis=0) / masses.sum()
    return com

def make_cubic_grid(coords_bohr_shifted, spacing_bohr, padding_bohr):
    mins = coords_bohr_shifted.min(axis=0)
    maxs = coords_bohr_shifted.max(axis=0)
    span = float((maxs - mins).max())
    L = span + 2.0*padding_bohr
    N = int(math.ceil(L/spacing_bohr)) + 1
    if N % 2 == 0: N += 1
    lin = np.linspace(-0.5*L, 0.5*L, N)
    X, Y, Z = np.meshgrid(lin, lin, lin, indexing="xy")
    origin = (-0.5*L, -0.5*L, -0.5*L)
    return (X, Y, Z), (N, N, N), origin, spacing_bohr

def _cube_header(natoms, origin, N, h):
    ox, oy, oz = origin
    nx, ny, nz = N
    lines = [
      "CUBE FILE generated by libint_fuzzy",
      "MO amplitude on cubic grid (bohr)",
      f"{natoms:5d} {ox:12.6f} {oy:12.6f} {oz:12.6f}",
      f"{nx:5d} {h:12.6f} {0.0:12.6f} {0.0:12.6f}",
      f"{ny:5d} {0.0:12.6f} {h:12.6f} {0.0:12.6f}",
      f"{nz:5d} {0.0:12.6f} {0.0:12.6f} {h:12.6f}",
    ]
    return "\n".join(lines) + "\n"

def _atom_line(Z, x, y, z):
    return f"{int(Z):5d} {float(Z):12.6f} {x:12.6f} {y:12.6f} {z:12.6f}\n"

def _write_mo_slab_to_buffer(row2d: np.ndarray, per_line: int = 24) -> str:
    # Build a big string for this slab for one MO (fewer writes)
    ny, nx = row2d.shape
    out_lines = []
    line = []
    count = 0
    for jy in range(ny):
        v = row2d[jy, :]
        for val in v:
            line.append(f"{val:13.5e}")
            count += 1
            if count % per_line == 0:
                out_lines.append(" ".join(line) + "\n")
                line = []
    if line:
        out_lines.append(" ".join(line) + "\n")
    return "".join(out_lines)

def write_mo_cubes(prefix, syms_qd, coords_qd_ang, shells, C_ao_mo,
                   mo_indices, spacing_bohr=0.40, padding_bohr=6.0,
                   part="real", outdir="cubes", nthreads=1,
                   per_line=24, fsync_every=0,  # fsync_every slabs (0=never)
                   verbose=True):

    import io, sys, time, os
    from concurrent.futures import ThreadPoolExecutor

    t_all0 = time.perf_counter()
    stage = {}

    if verbose: print("[cube] starting...", flush=True)
    os.makedirs(outdir, exist_ok=True)

    # --- init + geometry ---
    t0 = time.perf_counter()
    coords_bohr = np.asarray(coords_qd_ang, float) * config.BOHR_PER_ANGSTROM
    Znums = atomic_numbers_from_symbols(syms_qd)
    com = center_of_mass(Znums, coords_bohr)
    coords_shift = coords_bohr - com[None,:]
    stage["init_geom"] = time.perf_counter() - t0
    if verbose: print(f"[cube] geometry ready in {stage['init_geom']:.3f}s", flush=True)

    # --- grid ---
    t0 = time.perf_counter()
    (X, Y, Z), (nx, ny, nz), origin, h = make_cubic_grid(coords_shift, spacing_bohr, padding_bohr)
    stage["grid_build"] = time.perf_counter() - t0

    nao = C_ao_mo.shape[0]
    mo_indices = list(mo_indices)
    nm = len(mo_indices)
    if nm == 0:
        print("[cube] nothing to export (mo_indices is empty) — skipping.", flush=True)
        return []

    pts_per_slab = nx*ny
    total_pts = nx*ny*nz
    print(f"[cube] Grid {nx}x{ny}x{nz}={total_pts:,} | h={h:.4f} bohr | pad={padding_bohr:.2f} bohr", flush=True)
    print(f"[cube] N_AO={nao:,} | MOs={nm} | pts/slab={pts_per_slab:,} | slabs={nz}", flush=True)
    print(f"[cube] Threads (C++ eval+proj) = {nthreads}", flush=True)

    # --- coeffs ---
    t0 = time.perf_counter()
    Csub = np.asarray(C_ao_mo[:, mo_indices], dtype=np.complex128, order="F")
    stage["coeff_slice"] = time.perf_counter() - t0
    if verbose: print(f"[cube] coeff slice {stage['coeff_slice']:.3f}s", flush=True)

    # --- files (.part during run) ---
    t0 = time.perf_counter()
    files = []
    temp_paths = []
    for j, mo in enumerate(mo_indices):
        tmp = os.path.join(outdir, f"{prefix}_mo{mo+1:04d}.part")
        f = io.open(tmp, mode="w", buffering=2**20)
        f.write(_cube_header(len(Znums), origin, (nx,ny,nz), h))
        for Zk, (x,y,z) in zip(Znums, coords_shift):
            f.write(_atom_line(Zk, x, y, z))
        files.append(f)
        temp_paths.append(tmp)
    stage["headers"] = time.perf_counter() - t0
    print(f"[cube] opened {nm} .part file(s); headers+atoms {stage['headers']:.3f}s", flush=True)

    # --- helpers ---
    def slab_points(kz):
        # stack grid points (Ny*Nx, 3) in the COM-centered frame …
        P = np.stack(
            [X[:, :, kz].ravel(), Y[:, :, kz].ravel(), Z[:, :, kz].ravel()],
            axis=1
        )
        # …then evaluate at absolute coordinates so shells don't need shifting
        return P + com.reshape(1, 3)
    
    def slab_buffer(row2d: np.ndarray) -> str:
        ny_, nx_ = row2d.shape
        out_lines, line, count = [], [], 0
        for jy in range(ny_):
            v = row2d[jy, :]
            for val in v:
                line.append(f"{val:13.5e}")
                count += 1
                if count % per_line == 0:
                    out_lines.append(" ".join(line) + "\n")
                    line = []
        if line: out_lines.append(" ".join(line) + "\n")
        return "".join(out_lines)

    # --- loop ---
    t_evalproj = 0.0
    t_io = 0.0
    last_print = time.perf_counter()

    for kz in range(nz):
        print(f"[cube] slab {kz+1}/{nz} : building points...", flush=True)
        P = slab_points(kz)
        if kz == 0:
            print(f"[cube] COM (bohr): {com}", flush=True)
            print(f"[cube] first grid point (centered): {P[0]-com}", flush=True)
            print(f"[cube] first eval point (absolute): {P[0]}", flush=True)

        print(f"[cube] slab {kz+1}/{nz} : C++ eval+project...", flush=True)
        t0 = time.perf_counter()
        Psi = libint_fuzzy.project_mos_points(shells, Csub, P, part, nthreads)  # (nm, Ny*Nx)
        t1 = time.perf_counter()
        t_evalproj += (t1 - t0)
        print(f"[cube] slab {kz+1}/{nz} : eval+proj done in {t1-t0:.3f}s", flush=True)

        print(f"[cube] slab {kz+1}/{nz} : writing...", flush=True)
        t2 = time.perf_counter()
        row2ds = [Psi[j].reshape(ny, nx) for j in range(nm)]
        # write per-MO in threads
        with ThreadPoolExecutor(max_workers=min(8, nm)) as ex:
            for j, buf in enumerate(ex.map(slab_buffer, row2ds)):
                files[j].write(buf)
        # optional flush & fsync every N slabs (N=fsync_every)
        if fsync_every and ((kz+1) % fsync_every == 0):
            for f in files:
                f.flush()
                os.fsync(f.fileno())
        else:
            # still flush Python buffers so tail shows up in Finder/ls
            for f in files:
                f.flush()
        t3 = time.perf_counter()
        t_io += (t3 - t2)
        print(f"[cube] slab {kz+1}/{nz} : wrote in {t3-t2:.3f}s  (cum eval+proj {t_evalproj:.1f}s | cum I/O {t_io:.1f}s)", flush=True)

    # --- close + rename ---
    print("[cube] closing files...", flush=True)
    t0 = time.perf_counter()
    for f in files:
        f.flush()
        if fsync_every:
            os.fsync(f.fileno())
        f.close()
    stage["close"] = time.perf_counter() - t0

    print("[cube] renaming .part → .cube ...", flush=True)
    t0 = time.perf_counter()
    final_paths = []
    for tmp, mo in zip(temp_paths, mo_indices):
        final = os.path.join(outdir, f"{prefix}_mo{mo+1:04d}.cube")
        os.replace(tmp, final)
        final_paths.append(final)
    stage["rename"] = time.perf_counter() - t0

    total = time.perf_counter() - t_all0
    print("\n[cube] Timing summary:")
    print(f"  init/geom:     {stage['init_geom']:8.3f} s")
    print(f"  grid build:    {stage['grid_build']:8.3f} s")
    print(f"  coeff slice:   {stage['coeff_slice']:8.3f} s")
    print(f"  headers/atoms: {stage['headers']:8.3f} s")
    print(f"  eval+project:  {t_evalproj:8.3f} s")
    print(f"  I/O writing:   {t_io:8.3f} s")
    print(f"  close files:   {stage['close']:8.3f} s")
    print(f"  rename files:  {stage['rename']:8.3f} s")
    print(f"  TOTAL:         {total:8.3f} s  → wrote {nm} cube(s) in {outdir}/", flush=True)

    return final_paths



